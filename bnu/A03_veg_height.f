!simard.f
!Assign tree heights from Simard et al. (2011) to tree PFTs in 
! EntMM_lc_maxlai_#x#.bin generated by modis_entpftg.f.

! GFORTRAN COMPILATION:
! ulimit -s unlimited
! module purge
! module load other/comp/gcc-4.9.2-sp3
! module load other/ncl-6.3.0

! gfortran -c -cpp -mcmodel=medium -fconvert=big-endian -O2 -fno-range-check -I/usr/local/other/SLES11.3/netcdf/3.6.3/gcc-4.9.2-sp3/include arrayutil.f

! gfortran -c -cpp -mcmodel=medium -fconvert=big-endian -O2 -fno-range-check -I/usr/local/other/SLES11.3/netcdf/3.6.3/gcc-4.9.2-sp3/include A03_veg_height.f

! gfortran -o myExe arrayutil.o A03_veg_height.o -L/usr/local/other/SLES11.3/netcdf/3.6.3/gcc-4.9.2-sp3/lib -lnetcdf

! ./myExe

      module simard_mod

      implicit none
      private
      save

!      public IMH,JMH,IM1,JM1,IM2,JM2
      public gform,IJMULT,IJDIV,IJADD,IJSUB,MULT,DIV,ADD
      public Set_shrub_height
      public long,lat, ENTPFTNUM
      public EntPFT_title
      public GRASS, HERB, SHRUB, TREE, BARREN
      public undef
      public evbroades, evbroadls, evneedlees, evneedlels, 
     &     colddecidbroades, colddecidbroadls, droughtdecid, 
     &     decidneedle, coldshrub, aridshrub, 
     &     C3grassperr, C4grass, C3grassann, C3grassarctic, 
     &     C3cropherb, C4cropherb, broadcroptree, ice, bare

      real*4, parameter :: undef = -1e30

      integer, parameter :: X1km = 43200 !long at 1 km
      integer, parameter :: Y1km = 21600 !lat at 1 km

      integer, parameter :: long = X1km
      integer, parameter :: lat = Y1km

      integer, parameter :: ENTPFTNUM = 19 !17 Ent PFTs + snow/ice + bare

      integer, parameter :: GRASS = 1
      integer, parameter :: HERB = 2
      integer, parameter :: SHRUB = 3
      integer, parameter :: TREE = 4
      integer, parameter :: BARREN = 5

      integer, parameter :: evbroades = 1
      integer, parameter :: evbroadls = 2
      integer, parameter :: evneedlees = 3
      integer, parameter :: evneedlels = 4
      integer, parameter :: colddecidbroades = 5
      integer, parameter :: colddecidbroadls = 6
      integer, parameter :: droughtdecid = 7
      integer, parameter :: decidneedle = 8
      integer, parameter :: coldshrub = 9
      integer, parameter :: aridshrub = 10
      integer, parameter :: C3grassperr = 11
      integer, parameter :: C4grass = 12
      integer, parameter :: C3grassann = 13
      integer, parameter :: C3grassarctic = 14
      integer, parameter :: C3cropherb = 15
      integer, parameter :: C4cropherb = 16
      integer, parameter :: broadcroptree = 17
      integer, parameter :: ice = 18
      integer, parameter :: bare = 19

           !***************************************************
      !*      ENT PLANT FUNCTIONAL TYPES                 *
      !***************************************************
      character*50, parameter :: EntPFT_title(19) =
     &     (/
     &     '1 - evergreen broadleaf early successional       ',
     &     '2 - evergreen broadleaf late successional        ',
     &     '3 - evergreen needleleaf early successional      ',
     &     '4 - evergreen needleleaf late successional       ',
     &     '5 - cold deciduous broadleaf early successional  ',
     &     '6 - cold deciduous broadleaf late successional   ',
     &     '7 - drought deciduous broadleaf                  ',
     &     '8 - deciduous needleleaf                         ',
     &     '9 - cold adapted shrub                           ',
     &     '10 - arid adapted shrub                          ',
     &     '11 - C3 grass perennial                          ',
     &     '12 - C4 grass                                    ',
     &     '13 - C3 grass - annual                           ',
     &     '14 - arctic C3 grass                             ',
     &     '15 - crops C3 herb                               ',
     &     '16 - crops C4 herb                               ',
     &     '17 - crops woody                                 ',
     &     '18 - Permanent snow/ice                          ',
     &     '19 - Bare or sparsely vegetated, urban           '
     &     /)


      contains

!------------------------------------------------------------------------

      integer function gform(PFT)
      integer :: PFT

      if ((PFT.ge.1).and.(PFT.le.8)) then
         gform = TREE
      elseif ((PFT.eq.9).or.(PFT.eq.10)) then
         gform = SHRUB
      elseif ((PFT.ge.11).and.(PFT.le.14)) then
         gform = GRASS
      elseif ((PFT.eq.15).or.(PFT.eq.16)) then
         gform = HERB
      elseif (PFT.eq.17) then
         gform = TREE
      else
         gform = BARREN
      endif

      end function gform


      subroutine IJDIV(num, denom, out)
      implicit none
      real*4 :: num(long,lat),denom(long,lat),out(long,lat)
      integer :: i,j
      do i=1,long
         do j=1,lat
            if ((denom(i,j).eq.0.).or.(denom(i,j).eq.undef)) then
               out(i,j) = 0.
            elseif (num(i,j).eq.undef) then
               out(i,j) = undef
            else
               out(i,j) = num(i,j)/denom(i,j)
            endif
         enddo
      enddo
      end subroutine IJDIV

      subroutine IJMULT(fac1, fac2, out)
      implicit none
      real*4 :: fac1(long,lat),fac2(long,lat),out(long,lat)
      integer :: i,j
      do i=1,long
         do j=1,lat
            if ((fac1(i,j).eq.undef).or.(fac2(i,j).eq.undef)) then
               out(i,j) = undef
            else
               out(i,j) = fac1(i,j)*fac2(i,j)
            endif
         enddo
      enddo
      end subroutine IJMULT

      subroutine IJSUB(fac1, fac2, out)
      implicit none
      real*4 :: fac1(long,lat),fac2(long,lat),out(long,lat)
      integer :: i,j
      do i=1,long
         do j=1,lat
            if ((fac1(i,j).eq.undef).or.(fac2(i,j).eq.undef)) then
               out(i,j) = undef
            else
               out(i,j) = fac1(i,j)-fac2(i,j)
            endif
         enddo
      enddo
      end subroutine IJSUB

      subroutine IJADD(fac1, fac2, out)
      implicit none
      real*4 :: fac1(long,lat),fac2(long,lat),out(long,lat)
      integer :: i,j
      do i=1,long
         do j=1,lat
            if ((fac1(i,j).eq.undef).or.(fac2(i,j).eq.undef)) then
               out(i,j) = undef
            else
               out(i,j) = fac1(i,j)+fac2(i,j)
            endif
         enddo
      enddo
      end subroutine IJADD

      real*4 function MULT(fac1,fac2,defval)
      implicit none
      real*4 :: fac1, fac2,defval
      if ((fac1.eq.undef).or.(fac2.eq.undef)) then
         MULT = defval
      else
         MULT = fac1 * fac2
      endif
      end function MULT

      real*4 function DIV(fac1,fac2,defval)
      real*4 :: fac1, fac2, defval
      if ((fac1.eq.undef).or.(fac2.eq.undef)) then
         DIV = defval
      elseif (fac2.eq.0.) then
         DIV  = 0.
      else
         DIV = fac1/fac2
      endif
      end function DIV

      real*4 function ADD(fac1,fac2,defval)
      real*4 :: fac1, fac2, defval
      !---
      real*4 :: fac1d, fac2d
      if (defval.eq.undef) then
         if ((fac1.eq.undef).or.(fac2.eq.undef)) then
            ADD= undef
         endif
         RETURN
      endif

      if (fac1.eq.undef) then
         fac1d = defval
      else
         fac1d = fac1
      endif
      if (fac2.eq.undef) then
         fac2d = defval
      else
         fac2d = fac2
      endif
      ADD = fac1d + fac2d
      RETURN

      end function ADD


      subroutine Set_shrub_height(pft,h)
      implicit none
      integer :: pft
      real*4 :: h

      if (pft.eq.coldshrub) then
         h = 0.365 !0.365 is average from Bret-Harte et al. 2002 !Old: 0.1
      elseif (pft.eq.aridshrub) then
         h = 2.0   !Check value of a1h for allometry. Need h << a1h.
      endif
      end subroutine Set_shrub_height

      end module simard_mod

!------------------------------------------------------------------------
      subroutine calc_lon_lat_HxH(IMH,JMH,lon,lat)
      implicit none
      integer,intent(in) :: IMH,JMH
      real*4,intent(inout) :: lon(IMH),lat(JMH)
      integer :: i,j

      do i=1,IMH
         lon(i) = -180.0 + 0.5*i - 0.5
      end do

      do j=1,JMH
         lat(j) = -90.0 + 0.5*j - 0.5
      end do

      end subroutine calc_lon_lat_HxH

!-----------------------------------------------------------------
      
      program simard
      use simard_mod
      implicit none
      include 'netcdf.inc'
      
!***************************************************
!*      PREFIX OF ENTPFTS FILES FOR LC AND LAI     *
!***************************************************
      character*3, parameter :: EntPFT_files1(19) =
     &     (/
     &     '01_',
     &     '02_',
     &     '03_',
     &     '04_',
     &     '05_',
     &     '06_',
     &     '07_',
     &     '08_',
     &     '09_',
     &     '10_',
     &     '11_',
     &     '12_',
     &     '13_',
     &     '14_',
     &     '15_',
     &     '16_',
     &     '17_',
     &     '18_',
     &     '19_'
     &     /)

!***************************************************
!*      SUFIX OF ENTPFTS FILES FOR LC AND LAI     *
!***************************************************
      character*14, parameter :: EntPFT_files2(19) =
     &     (/
     &     'ever_br_early ',
     &     'ever_br_late  ',
     &     'ever_nd_early ',
     &     'ever_nd_late  ',
     &     'cold_br_early ',
     &     'cold_br_late  ',
     &     'drought_br    ',
     &     'decid_nd      ',
     &     'cold_shrub    ',
     &     'arid_shrub    ',
     &     'c3_grass_per  ',
     &     'c4_grass      ',
     &     'c3_grass_ann  ',
     &     'c3_grass_arct ',
     &     'crops_c3_herb ',
     &     'crops_c4_herb ',
     &     'crops_woody   ',
     &     'snow_ice      ',
     &     'bare_sparse   '
     &     /)

      character*80 :: TITLE
      character*256 :: file_EntMM !10
      character*256 :: file_simard !20
      character*256 :: file_calc !30
      character*256 :: file_GVSD !40
      character*256 :: file_GVSDA !50
      character*50 :: PATHEnt, PATHfile
      character*5 :: RESOUT
      integer :: skip

      integer, parameter :: X1km = 43200 !long at 1 km
      integer, parameter :: Y1km = 21600 !lat at 1 km

      integer, parameter :: IM1km = X1km !long at 1 km
      integer, parameter :: JM1km = Y1km !lat at 1 km
      
      integer, parameter :: longout = 1
      integer, parameter :: latout = 1

      character*256 :: PathFilepre,PathFilepost

      character*256 :: fileoutnc
      integer :: ncidin,ncidout,varid,status
      character*20 :: inqvarin, inqvarout

      real*4 :: LAYERIN
      real*4 :: LAYEROUT
      real*4 :: LAYEROUTA
      real*4 :: SHEIGHT,STDEV,SCOVER    !Simard
      real*4 :: EntMMCOVER
      real*4 :: EntGVSD(ENTPFTNUM)
      real*4 :: STDEVPFT(ENTPFTNUM) !Std dev by PFT
      real*4 :: STDEVPFTA(ENTPFTNUM) !Std dev by PFT for AViewer

      integer :: i,j,k,p
      real*4 :: h
      integer :: form

      real*4 :: lon(longout),lati(latout)

      integer, parameter :: IndX = 1
      integer, parameter :: IndY = 1
      integer :: err,fileid,fileidin,fileidout,dimidx,dimidy,dimidz
      integer :: ycoord, xcoord

      character*256 :: fileinsim,fileinlc,fileout

      integer :: fileidsim,varidsim
      integer :: fileidlc(19),varidlc(19)
      integer :: varidout

      integer :: startA(1),startB(2),countA(1),countB(2)
      integer :: startX(1),startY(1),countX(1),countY(1)
      integer :: start3d(4),count3d(4)
      integer :: dd(4),varidx,varidy

! ----------------------------------------------------------------------
!     GET NC FILES IDs
      
!     SIMARD HEIGHTS
      PathFilepre= '../../data/height/'
      PathFilepost= 'simard_forest_heights.nc'
      fileinsim  =  trim(PathFilepre)//trim(PathFilepost)
      err = NF_OPEN(fileinsim,NF_WRITE,fileidsim)
!      write(*,*) err
      err = NF_INQ_VARID(fileidsim,'heights',varidsim)
!      write(*,*) err

      err = NF_INQ_VARID(fileidsim,'lon',varidx)
!      write(*,*) err
      err = NF_INQ_VARID(fileidsim,'lat',varidy)
!      write(*,*) err
!
!     ENTPFTLC
      do k = 1,ENTPFTNUM
         PathFilepre= '../lc_lai_ent/EntMM_lc_laimax_1kmx1km/'
         fileinlc = trim(PathFilepre)//trim(EntPFT_files1(k))//
     &        trim(EntPFT_files2(k))//'_lc.nc'
         err = NF_OPEN(fileinlc,NF_WRITE,fileidlc(k))
 !        write(*,*) err
         inqvarin = trim(EntPFT_files2(k))
         err = NF_INQ_VARID(fileidlc(k),inqvarin,varidlc(k))
!         write(*,*) err
      enddo

!     ENTPFT heights

      PathFilepre= '../../data/height/'
      PathFilepost= 'EntGVSDmosaic17_height_1kmx1km_lai3g.nc'
      fileout = trim(PathFilepre)//trim(PathFilepost)
      err = NF_OPEN(fileout,NF_WRITE,fileidout)
!      write(*,*) err
      inqvarin = 'SimardHeights'
      err = NF_INQ_VARID(fileidout,inqvarin,varidout)
!      write(*,*) err      

!     main loop
      do ycoord = 1,JM1km

         do xcoord = 1,IM1km

            !**   lon lat from simard 1kmx1km file

            if (xcoord.eq.1) then
               startY(1) = ycoord
               countY(1) = 1
               err = NF_GET_VARA_REAL(fileidsim,varidy,startY,
     &              countY,lati)
               err = NF_PUT_VARA_REAL(fileidout,varidy,startY,
     &              countY,lati)
!     	       write(*,*) err
            endif

            if (xcoord.eq.1) then
               write(*,*) 'ycoord', ycoord, 'lat', lati
            endif
            
            if (ycoord.eq.1) then
               startX(1) = xcoord
               countX(1) = 1
               err = NF_GET_VARA_REAL(fileidsim,varidx,startX,
     &              countX,lon)
               err = NF_PUT_VARA_REAL(fileidout,varidx,startX,
     &              countX,lon)
!	       write(*,*) err
            endif
            
!**   Simard heights data
            
            startB(1)=xcoord
            startB(2)=ycoord
            countB(1)=1
            countB(2)=1
            
            err = NF_GET_VARA_REAL(fileidsim,varidsim,startB,countB,
     &           SHEIGHT)
!            write(*,*) err, 'SHEIGHT ',(SHEIGHT)
	    if (SHEIGHT.eq.0) then
		SHEIGHT = undef
	    endif
!            write(*,*) err, 'SHEIGHT ',(SHEIGHT)

            do p = 1,ENTPFTNUM
               err = NF_GET_VARA_REAL(fileidlc(p),varidlc(p),startB,
     &              countB,EntMMCOVER)
!               write(*,*) err, 'EntMMCOVER ',(EntMMCOVER)
               form = gform(p)
!               write(*,*) p, form
               LAYEROUT = undef
               if (EntMMCOVER.gt.0.) then
                  !write(*,*) p, form,LAYERIN(i,j)
                  if (form.eq.GRASS) then
                     if ((p.eq.C3grassann).or.(p.eq.C3grassarctic)) then
                        LAYEROUT = 0.5
                        !STDEVPFT(p,i,j) = 0.5*LAYEROUT(i,j) !Arbitrary
                     else
                        LAYEROUT = 1.5
                        !STDEVPFT(p,i,j) = 0.5*LAYEROUT(i,j) !Arbitrary
                     endif
                  elseif (form.eq.HERB) then
                     LAYEROUT = 0.5
                     !STDEVPFT(p,i,j) = 0.5*LAYEROUT(i,j) !Arbitrary
                  elseif (form.eq.SHRUB) then
                     call Set_Shrub_height(p,h)
                     LAYEROUT = h
                     !LAYEROUT(i,j) = SHEIGHT(i,j)
                     !STDEVPFT(p,i,j) = 0.5*LAYEROUT(i,j) !Arbitrary
                  elseif (form.eq.TREE) then
                     LAYEROUT = SHEIGHT
!		     write(*,*) LAYEROUT
                     !STDEVPFT(p,i,j) = STDEV(i,j) !Simard forest value
                  else
                     LAYEROUT = 0.0
                  endif
                  !Assign for AViewer
                  !if (LAYEROUT(i,j).ne.0.0) then
                  !   LAYEROUTA(i,j) = LAYEROUT(i,j)
                  !   STDEVPFTA(p,i,j) = STDEVPFT(p,i,j)
                  !else
                  !   LAYEROUTA(i,j) = undef
                  !   STDEVPFTA(p,i,j) = undef
                  !endif

               endif

!               write(*,*) 'End of loop ', p
               
               start3d(1) = p
               start3d(2) = xcoord
               start3d(3) = ycoord
               count3d(1) = 1
               count3d(2) = 1
               count3d(3) = 1

	       err=NF_PUT_VARA_REAL(fileidout,varidout,
     &             start3d,count3d,LAYEROUT)
!	       write(*,*) LAYEROUT,err
            enddo

         enddo
      enddo
      
      end program simard

